// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model ProfilePicture {

  id          String   @id @default(cuid())
  userID      String
  user        User     @relation(fields: [userID], references: [id], onDelete: Cascade)

  signedUrl String? // Signed URL for profile picture (cached)
  storagePath String // Storage path for profile picture
  cachedUntil DateTime? // Optional: when the cached URL expires
  isPrimary  Boolean  @default(false) // If user has multiple, which one is primary
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

}

/**
There will be many users and multiple admins
*/
model User {
  id              String    @id @default(cuid())
  name            String?   @unique
  email           String    @unique
  password        String?   // Password is crucial in oss
  profilePictures  ProfilePicture[]    // Signed URL for profile picture (cached)
  bio             String?   // Profile bio
  dateOfBirth     DateTime? // User's date of birth
  pronouns        String?   // User's pronouns
  showAge         Boolean   @default(true) // Privacy setting for showing age
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  registration    Registration?
  payments        Payment[]
  isAdmin         Boolean   @default(false)
  isVerified      Boolean   @default(false) // Your field
  eventsOwned     Event[]
  accounts        Account[]
  sessions        Session[]
  Authenticator   Authenticator[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String  @map("user_id")
  type              String
  provider          String
  providerAccountId String  @map("provider_account_id")
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id")
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@unique([identifier, token])
  @@map("verificationtokens")
}

/**
  Event-Singleton - In OSS, there will be only be one event at a time
  With @default(1) for the id, we can have only one event at a time
*/
model Event {
  id            Int     @id @default(autoincrement())
  name          String
  description   String
  startDate     DateTime
  endDate       DateTime
  imageUrl      String?
  status        EventStatus @default(DRAFT)
  stayPolicy    Json        @default("{}")
  ownerId       String? // temporary nullable for migration; will backfill and make required
  owner         User?       @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  location      Location?
  products      Product[]

  // registrations Registration[]
}

/**
  Location model to store event locations. As 1:1 relationship with event
  This will be a venue, most likely a hotel or a conference center
  This will be a children of the event model and act as a datatype instead of an independent table
*/
model Location {
  id            Int       @id @default(1) // 1:1 relationship with event for singleton pattern
  name          String
  address       String
  city          String
  state         String
  country       String
  postalCode    String
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  event         Event     @relation(fields: [eventId], references: [id], onDelete: Cascade)
  eventId       Int       @unique // For 1:1 relationship with event
}

/**
  Registration model to store user registrations for the event
  Normally, there will be only one registration per user
  And we could get rid of ticketId and use the normal id as auto-increment, but that means we need to wipe the database every time we want a new event
*/
model Registration {
  id            String              @id @default(cuid())
  ticketId      Int                 @default(autoincrement()) @unique
  status        RegistrationStatus  @default(PENDING)
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  userId        String              @unique  
  user          User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  payments      Payment[]
}


model Payment {
  id              String        @id @default(cuid())
  amount          Float
  currency        String
  paymentStatus   PaymentStatus @default(PENDING)
  paymentProvider String?                         // Stripe, PayPal, Bank Transfer, etc.
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  userId          String
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  registrationId  String
  registration    Registration  @relation(fields: [registrationId], references: [id], onDelete: Cascade)
}

/**
  Product model to store products for the event
  For example, badges, t-shirts, sponsorships, etc etc.
*/
model Product {
  id            String   @id @default(cuid())
  name          String
  description   String?
  price         Float
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  eventId       Int      @default(1)
  event         Event    @relation(fields: [eventId], references: [id])
}

enum RegistrationStatus {
  PENDING
  CONFIRMED
  CANCELLED
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum EventStatus {
  DRAFT
  PUBLISHED
  CANCELLED
}

model Authenticator {
  // id                    String   @id @default(cuid())
  credentialID          String   @unique
  userId                String
  providerAccountId     String
  credentialPublicKey   String
  counter               Int
  credentialDeviceType  String
  credentialBackedUp    Boolean
  transports            String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, credentialID])
}