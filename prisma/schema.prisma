// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}


/**
There will be many users and multiple admins
*/
model User {
  id              String   @id @default(cuid())
  name            String?  @unique
  email           String   @unique
  password        String  // Password is crucial in oss
  profilePicture  String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  registration    Registration?
  payments        Payment[]
  isAdmin         Boolean  @default(false)
  isVerified      Boolean  @default(false)
}

/**
  Event-Singleton - In OSS, there will be only be one event at a time
  With @default(1) for the id, we can have only one event at a time
*/
model Event {
  id            Int     @id @default(1)
  name          String
  description   String?
  startDate     DateTime
  endDate       DateTime
  imageUrl      String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  location      Location?
  products      Product[]

  // registrations Registration[]
}

/**
  Location model to store event locations. As 1:1 relationship with event
  This will be a venue, most likely a hotel or a conference center
  This will be a children of the event model and act as a datatype instead of an independent table
*/
model Location {
  id            Int       @id @default(1) // 1:1 relationship with event for singleton pattern
  name          String
  address       String
  city          String
  state         String
  country       String
  postalCode    String
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  event         Event     @relation(fields: [eventId], references: [id])
  eventId       Int       @unique // For 1:1 relationship with event
}

/**
  Registration model to store user registrations for the event
  Normally, there will be only one registration per user
  And we could get rid of ticketId and use the normal id as auto-increment, but that means we need to wipe the database every time we want a new event
*/
model Registration {
  id            String              @id @default(cuid())
  ticketId      Int                 @default(autoincrement()) @unique
  status        RegistrationStatus  @default(PENDING)
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  userId        String              @unique  
  user          User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  payments      Payment[]
}


model Payment {
  id              String        @id @default(cuid())
  amount          Float
  currency        String
  paymentStatus   PaymentStatus @default(PENDING)
  paymentProvider String?                         // Stripe, PayPal, Bank Transfer, etc.
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  userId          String
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  registrationId  String
  registration    Registration  @relation(fields: [registrationId], references: [id], onDelete: Cascade)
}

/**
  Product model to store products for the event
  For example, badges, t-shirts, sponsorships, etc etc.
*/
model Product {
  id            String   @id @default(cuid())
  name          String
  description   String?
  price         Float
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  eventId       Int      @default(1)
  event         Event    @relation(fields: [eventId], references: [id])
}

enum RegistrationStatus {
  PENDING
  CONFIRMED
  CANCELLED
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

